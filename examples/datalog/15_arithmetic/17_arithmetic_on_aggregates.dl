// Test: Arithmetic Operations on Aggregation Results
// Category: Arithmetic + Aggregation
// Verifies: Applying arithmetic to aggregated values
// CRITICAL: Tests integration between aggregation and arithmetic

.db create test_arith_agg
.db use test_arith_agg

// Sales data: store, product, amount
+sales[(1, 100, 500), (1, 101, 300), (1, 102, 200),
       (2, 100, 400), (2, 101, 600),
       (3, 100, 700), (3, 101, 100), (3, 102, 200), (3, 103, 300)].

// Basic aggregations
view store_total(Store: int, sum<Amount>: int) :- sales(Store, _, Amount).
view store_count(Store: int, count<Product>: int) :- sales(Store, Product, _).

?- store_total(S, T).
?- store_count(S, C).

// Arithmetic on aggregation results: double the total
view doubled_total(Store: int, Total*2: int) :- store_total(Store, Total).
?- doubled_total(S, D).

// Expected: Store 1: 2000, Store 2: 2000, Store 3: 2600

// Calculate average from sum and count (manual avg)
view manual_avg(Store: int, Total/Count: int) :- store_total(Store, Total), store_count(Store, Count).
?- manual_avg(S, A).

// Compare with built-in avg
view builtin_avg(Store: int, avg<Amount>: int) :- sales(Store, _, Amount).
?- builtin_avg(S, A).

// Percentage of grand total
view grand_total(sum<A>: int) :- sales(_, _, A).
?- grand_total(G).

// Store percentage (requires join with grand total)
// store_pct(Store, Total*100/Grand) := store_total(Store, Total), grand_total(Grand).
// Note: This pattern may not work - depends on how global aggregates are handled

// Derived metrics: total + 10% bonus
view with_bonus(Store: int, Total + Total/10: int) :- store_total(Store, Total).
?- with_bonus(S, B).

// Cleanup
.db use default
.db drop test_arith_agg
