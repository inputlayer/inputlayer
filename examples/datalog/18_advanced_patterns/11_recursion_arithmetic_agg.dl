// Test: Recursion + Arithmetic + Aggregation Combined
// Category: Advanced Patterns
// Verifies: All three features working together
// CRITICAL: Complex integration test

.db create test_rec_arith_agg
.db use test_rec_arith_agg

// Weighted graph: edge(from, to, weight)
+edge[(1, 2, 10), (2, 3, 20), (3, 4, 15), (1, 3, 50), (2, 4, 25)].

// Compute all paths with total weight (recursion + arithmetic)
// Base case: direct edges
view path_weight(X: int, Y: int, W: int) :- edge(X, Y, W).

// Recursive case: extend path, accumulate weight
view path_weight(X: int, Z: int, W1+W2: int) :- path_weight(X, Y, W1), edge(Y, Z, W2).

// Query all path weights
?- path_weight(X, Y, W).

// Expected paths from 1:
// 1->2: 10
// 1->3: 50 (direct) and 30 (via 2)
// 1->4: 35 (1->2->4), 45 (1->2->3->4), 65 (1->3->4)

// Find minimum weight path using aggregation
view min_path(X: int, Y: int, min<W>: int) :- path_weight(X, Y, W).
?- min_path(X, Y, W).

// Expected: 1->2: 10, 1->3: 30, 1->4: 35, 2->3: 20, 2->4: 25, 3->4: 15

// Count number of distinct paths between each pair
view path_count(X: int, Y: int, count<W>: int) :- path_weight(X, Y, W).
?- path_count(X, Y, C).

// Total weight of all paths from node 1
view total_from_1(sum<W>: int) :- path_weight(1, _, W).
?- total_from_1(T).

// Average path weight from node 1
view avg_from_1(avg<W>: int) :- path_weight(1, _, W).
?- avg_from_1(A).

// Cleanup
.db use default
.db drop test_rec_arith_agg
