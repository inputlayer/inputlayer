// Test: Package Dependency Resolution
// Category: Applications
// Verifies: Transitive dependency analysis

.db create test_deps
.db use test_deps

// Package dependencies: depends(package, dependency)
+depends[(1, 2), (1, 3),     // pkg 1 depends on 2, 3
         (2, 4), (2, 5),     // pkg 2 depends on 4, 5
         (3, 5), (3, 6),     // pkg 3 depends on 5, 6
         (4, 7),             // pkg 4 depends on 7
         (5, 7), (5, 8),     // pkg 5 depends on 7, 8
         (6, 8)].            // pkg 6 depends on 8

// Transitive dependencies
view all_deps(Pkg: int, Dep: int) :- depends(Pkg, Dep).
view all_deps(Pkg: int, TransDep: int) :- depends(Pkg, Dep), all_deps(Dep, TransDep).

// All dependencies of package 1
view deps_of_1(D: int) :- all_deps(1, D).
?- deps_of_1(D).

// Count dependencies per package
view dep_count(Pkg: int, count<D>: int) :- all_deps(Pkg, D).
?- dep_count(P, C).

// Find leaf packages (no dependencies)
view has_deps(P: int) :- depends(P, _).
view leaf_pkg(P: int) :- depends(_, P), !has_deps(P).
?- leaf_pkg(P).

// Packages that depend on package 7 (reverse deps)
view reverse_dep(7: int, Pkg: int) :- all_deps(Pkg, 7).
?- reverse_dep(7, P).

// Shared dependencies (deps used by multiple packages)
view used_by(Dep: int, Pkg: int) :- all_deps(Pkg, Dep).
view use_count(Dep: int, count<P>: int) :- used_by(Dep, P).
?- use_count(D, C).

// Cleanup
.db use default
.db drop test_deps
