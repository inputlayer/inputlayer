// Test: Recursion Termination Edge Cases
// Category: Recursion
// Verifies: Recursion correctly terminates in tricky scenarios

.db create test_termination
.db use test_termination

// Test 1: Self-loop should not cause infinite loop
+loop_edge[(1, 1), (1, 2), (2, 3)].

view path_loop(X: int, Y: int) :- loop_edge(X, Y).
view path_loop(X: int, Z: int) :- loop_edge(X, Y), path_loop(Y, Z).

?- path_loop(1, X).

// Expected: Should terminate with 1, 2, 3 (self-loop doesn't cause infinite results)

// Test 2: Cycle should not cause infinite loop
+cycle_edge[(1, 2), (2, 3), (3, 1)].

view path_cycle(X: int, Y: int) :- cycle_edge(X, Y).
view path_cycle(X: int, Z: int) :- cycle_edge(X, Y), path_cycle(Y, Z).

?- path_cycle(1, X).

// Expected: Should terminate with 1, 2, 3 (reaches all nodes in cycle)

// Test 3: Already computed paths should not be recomputed
+diamond_edge[(1, 2), (1, 3), (2, 4), (3, 4)].

view path_diamond(X: int, Y: int) :- diamond_edge(X, Y).
view path_diamond(X: int, Z: int) :- diamond_edge(X, Y), path_diamond(Y, Z).

// Count unique paths from 1 to 4 (should be counted once, not duplicated)
view to_four(X: int) :- path_diamond(1, X), X = 4.
?- to_four(X).

// Expected: Just (4) once, not duplicated

// Test 4: Empty base case
+empty_edge[].
+empty_start[(1)].

view path_empty(X: int, Y: int) :- empty_edge(X, Y).
view path_empty(X: int, Z: int) :- empty_edge(X, Y), path_empty(Y, Z).

view reachable_empty(Y: int) :- empty_start(X), path_empty(X, Y).
?- reachable_empty(X).

// Expected: No results (empty edge relation means no paths)

.db use default
.db drop test_termination
