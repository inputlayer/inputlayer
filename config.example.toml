# InputLayer Configuration Template
#
# Copy this file to config.toml or config.local.toml and customize.
#
# Environment variable overrides:
#   INPUTLAYER_STORAGE__DATA_DIR=/custom/path
#   INPUTLAYER_STORAGE__DEFAULT_KNOWLEDGE_GRAPH=mykg
#   INPUTLAYER_STORAGE__PERSISTENCE__FORMAT=csv

[storage]
# Base directory for all knowledge graph storage
# Production example: "/var/lib/inputlayer/data"
# Development example: "./data"
data_dir = "./data"

# Default knowledge graph (created on startup if missing)
default_knowledge_graph = "default"

# Automatically create knowledge graphs if they don't exist
# Set to true for development, false for production
auto_create_knowledge_graphs = false

[storage.persistence]
# Storage format options:
# - "parquet": Columnar format, excellent compression (10x smaller than CSV)
#              Fast reads, schema-aware, recommended for production
# - "csv":     Human-readable, uncompressed, good for debugging
# - "bincode": Binary format, Rust-specific, fast but not portable
format = "parquet"

# Compression options:
# - "snappy": Fast compression with good ratio (recommended)
# - "gzip":   Slower but better compression
# - "none":   No compression (useful for debugging)
compression = "snappy"

# Auto-save interval in seconds
# 0 = manual save only (call save_database() or save_all())
# 300 = auto-save every 5 minutes
auto_save_interval = 0

# Enable write-ahead logging (WAL) for crash recovery
enable_wal = true

# -----------------------------------------------------------------------------
# DD-Native Persist Layer (Recommended)
# -----------------------------------------------------------------------------
[storage.persist]
# Enable the DD-native persistence layer
enabled = true

# Buffer size before flushing to disk (number of updates)
buffer_size = 10000

# Durability mode: immediate, batched, async
# - immediate: Sync to disk on each write (safest, slowest)
# - batched: Periodic sync (balanced performance/safety)
# - async: Fire-and-forget (fastest, may lose recent data on crash)
durability_mode = "immediate"

# Compaction window: retain this many historical versions (0 = keep all)
compaction_window = 0

# Auto-compact when a shard accumulates this many batch files (0 = disabled)
auto_compact_threshold = 10

# How often to check for auto-compaction, in seconds (0 = disabled)
auto_compact_interval_secs = 300

[storage.performance]
# Initial capacity for in-memory hash maps
# Higher values reduce reallocations but use more memory
initial_capacity = 10000

# Batch size for bulk insert/update operations
batch_size = 1000

# Enable async I/O for storage operations
async_io = true

# Number of worker threads (0 = use all CPU cores)
num_threads = 0

# Maximum rows returned per query result (0 = unlimited)
max_result_rows = 100000

# Maximum query cost budget (0 = unlimited)
max_query_cost = 0

[optimization]
# Enable join spanning tree planning
# Optimizes join order for better performance
enable_join_planning = true

# Enable SIP rewriting (Yannakakis semijoin reduction)
# Optimizes recursive query evaluation
enable_sip_rewriting = true

# Enable subplan sharing across rules
# Reuses common subexpressions to reduce computation
enable_subplan_sharing = true

# Enable boolean specialization (semiring selection)
# Optimizes queries with boolean constants
enable_boolean_specialization = false

[logging]
# Log level: "trace" | "debug" | "info" | "warn" | "error"
# "debug" is useful during development
# "info" is recommended for production
level = "info"

# Log format: "text" | "json"
# "text" is human-readable
# "json" is machine-parseable (useful for log aggregation)
format = "text"

# =============================================================================
# HTTP Server Configuration (WebSocket API + GUI)
# =============================================================================
#
# The HTTP server provides:
# - WebSocket API at /ws
# - AsyncAPI docs at /api/ws-docs (and YAML at /api/asyncapi.yaml)
# - Optional GUI dashboard at /

[http]
# Enable HTTP server
# When disabled, only the RPC server (QUIC+TLS) runs
enabled = true

# HTTP server bind address
# "127.0.0.1" for local access only
# "0.0.0.0" for external access
host = "127.0.0.1"

# HTTP server port
port = 8080

# Allowed CORS origins for API requests
# Empty list = allow all origins (development mode)
# Specify origins for production, e.g., ["https://myapp.com"]
cors_origins = []

[http.gui]
# Enable GUI dashboard serving
# When enabled, static files from static_dir are served at /
enabled = true

# Directory containing GUI static files
# Usually the output of a Vue/React build (e.g., "./gui/dist")
static_dir = "./gui/dist"

[http.auth]
# Authentication is always enabled. On first boot, an admin user is created
# with a password from one of these sources (checked in order):
#   1. INPUTLAYER_ADMIN_PASSWORD environment variable
#   2. bootstrap_admin_password config value below
#   3. Auto-generated random password (printed to stderr)
#
# A bootstrap API key is also created and printed to stderr on first boot.
# Use it with the CLI: inputlayer-client --api-key <key>

# bootstrap_admin_password = "your-secure-password"

# Session timeout in seconds (default: 24 hours)
session_timeout_secs = 86400

# -----------------------------------------------------------------------------
# Rate Limiting
# -----------------------------------------------------------------------------
[http.rate_limit]
# Maximum WebSocket messages per second per connection (0 = unlimited)
ws_max_messages_per_sec = 1000

# Maximum HTTP requests per second per IP address (0 = unlimited)
per_ip_max_rps = 0

# Notification ring buffer size for reconnect replay
notification_buffer_size = 4096
